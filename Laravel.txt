Artisan:

1.Artisan Console -> Interfase que se utiliza dentro do terminal referente ao laravel.

2.php artisan list -> para ver os comandos disponiveis para o artisan.

3.key:generate -> gera uma chave nova para a aplicação.

4.make -> criar arquivos já com o templet pronto.

5.migrate -> são as migrações

6.route -> visualizar as route

7. php artisan help make: "controller ou palavra desejada" -> Caso não saiba fazer um controle, ao digitar ele irá mostrar uma explicação.

8. php artisan instalar:client -> Gera o banco de dados, cria dentro das tabelas registro padrão pra parecer no sistema e ele cria pasta de estruturas que eu preciso que são individuais pra cada projeto baseado num banco de dados.

9. artisan Config -> Configurar ele para trabalhar com seus cron job, definir 1 cron job que ele irá requisitar do laravel os comandos necessários.

10. schedule -> dos comandos escrevendo o que precisa ser feito em php.



Routes:

1. crtl + p -> digitar o nome de qualquer arquivo e através disso ele acessa qualquer arquivo sem ter que suar a barra ao lado.

2. facades -> route:: get ('/', function() {
	                  return view ('welcome');

Estrutura pra acessar rapidamente o que é preciso, e só podem ser acessadas quando declaradas, caso contrário não é possivel acessar.

Route::get('/teste', function (){
	encho "/teste";
}

Caminho mais rapido para demonstrar, mas não é o mais eficiente de se trabalhar com as rotas, o correto seria referenciar um controller.

Exemplo de um controller:
- Route::get('usuarios', 'usuariosController@Index');    ou 

- Route:: controllers([
	'auth' => 'Auth\AuthController',
	'password' => 'Auth\PasswordController',
]); 

Obs: se eu declarar a rota pelo 'get', ele irá ler só os 'gets', se eu declarar a rota pelo 'post', ele irá ler só os 'post', agora se eu declarar um 'any', ele irá ler ambas funções.

Parametros:

Route::get('/teste/{teste}', function ($teste){
	encho $teste;
)};



Controllers, Views e Blade: 

php artisan make:controller UsuariosController => para criar um controller novo.

1.Dentro do arquivo criado:
class UsuariosController extends Controller
{
    public function index(){
            echo "Hello Word, do controller";
    }
}

2. Blade:
Compilador de código que executa o código antes do php, ele transforma, modifica para o php poder entender depois.

Comando do blade para mostrar/chamar uma variavel:
{{$texto}}

Utilizando if com blade:

@if($checagem == true)
	Checagem = true
@else
	Checagem = false
@endif

<br/> -- quebra de linha

@foreach($usuarios as $usuarios)
	{{ $usuarios }} <br/>
@endforeach


Banco de dados e Migrations:
Pra criar uma nova tabela migration => php artisan make:migration create_usuarios.

Para setar o banco de dados:
Ir no arquivo => ' .env '

.env => Arquivo aonde cada um irá setar suas funções

correção do erro da tabela de migração:
# O problema estava nesse DB_HOST!
# Ele estava DB_HOST = 127.0.0.1
# Provavelmente na hora de instalar o Mysql aqui nesse pc
# Ele veio com uma configuração que não aceita a conexão pelo IP
# Ou nao estava reconhecendo que 127.0.0.1 é o mesmo que localhost
# Dai o que eu fiz foi mudar para DB_HOST = localhost
# e funcionou normal
# então se tiver mais alguem com o mesmo problema
# E o .env dessa pessoa estiver com 127.0.0.1
# Muda pra localhost!!
# Vou desconectar e nos falamos no slack se precisar eu acesso de novo


1. php artisan migrate:rollback -> comando para voltar a migração, ou seja, volta a batch, conforme o numero de batch.

2. php artisan make:migration create_cliente_table --create=clientes
observação:
O ' --create=clientes ', já vai preencher com o nome da tabela com schema preenchido.
Ex:
 Schema::create('clientes', function (Blueprint $table) {
            $table->increments('id');
            $table->timestamps();
        }); 

Ai depois inseri o campo desejado pelo cliente:
 Schema::create('clientes', function (Blueprint $table) {
            $table->increments('id');
            $table->string('nome',60); -- passando 60 caractere como parametro para não deixar null.
            $table->string('endereco'); -- se não setar nada, ele não pode ser nulo por padrão.
            $table->integer('numero');
            $table->timestamps();
        });

3. php artisan migrate -> para rodar a migração.

4. php artisan make: model Cliente -> criando o model.

Eloquent e Model:

php artisan tinker -> interfase na linha de comando aonde eu posso acessar meu projeto pelo terminal.

1. $cliente = new App\Cliente;  -> criei um cliente vazio.

obs: preenchendo os dados do cliente vazio:
$cliente->nome = 'Cliente 1';
$cliente->endereco = 'Rua tal';
$cliente->numero = '123';

$cliente->save(); -- para salvar no banco de dados.

2. Outro exemplo de caminho:
$cliente = App\Cliente:: create (['nome' => 'Cliente 2', 'endereco' => 'Rua tal', 'numero' => '124']);

3. Quando acontece a mensagem de erro é porque você está deixando o campo mais dinamico, mas também inseguro e para se proteger contra os usuarios a gente utiliza a variavel abaixo:
Isso tem que estar dentro da class
{
protected $fillable = [
        'nome',
        'endereco',
        'numero';
    ];
}

4. Para fazer uma alteração/editar um cliente existente no tinker:

$cliente2 = App\Cliente::find(2); -- executa;

depois de executado:
$cliente2 -> endereco = 'Endereco modificado';
$cliente2-> save();